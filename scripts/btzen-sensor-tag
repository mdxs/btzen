#!/usr/bin/env python3
#
# BTZen - library to asynchronously access Bluetooth devices.
#
# Copyright (C) 2015-2021 by Artur Wroblewski <wrobell@riseup.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""
BTZen demo using SensorTag Bluetooth device.

The demo supports reconnection of device.
"""

import argparse
import asyncio
import logging
import uvloop
import typing as tp
from datetime import datetime

import btzen

logger = logging.getLogger()

async def read_sensors(args) -> None:
    #battery = btzen.BatteryLevel(args.mac, notifying=True)
    #tasks.append(battery_level(battery))

    devices = [ctor(args.mac, make=btzen.Make.SENSOR_TAG) for _, ctor, _ in SENSORS]
    async with btzen.connect(devices, interface=args.interface) as session:
        items = zip(SENSORS, devices)
        tasks = (reader(name, dev) for (name, _, reader), dev in items)
        await asyncio.gather(session, *tasks)

async def read_data(name: str, sensor) -> tp.Any:
    while btzen.is_active():
        try:
            value = await btzen.read(sensor)
        except asyncio.CancelledError as ex:
            # cancelled calls happen on device disconnection
            logger.info('{}/{}: {}'.format(name, sensor, ex))
        else:
            yield value

async def read_sensor(name: str, sensor) -> None:
    loop = asyncio.get_event_loop()
    async for value in read_data(name, sensor):
        print_data(name, '{:.1f}'.format(value))
        await asyncio.sleep(-loop.time() % 1)

async def read_accelerometer(name: str, sensor) -> None:
    #sensor.set_interval(0.1)
    async for values in read_data(name, sensor):
        values = ', '.join('{:.4f}'.format(v) for v in values)
        print_data(name, values)

async def read_button(name: str, button) -> None:
    async for value in read_data(name, button):
        print_data('button', value)

async def battery_level(name: str, battery) -> None:
    async for value in read_data(name, battery):
        print_data('battery level', value)

def print_data(name: str, value: tp.Union[str, int, float]) -> None:
    print('{} {}: {}'.format(datetime.now(), name, value))

#
# sensor definitions
#
SENSORS = [
    ('pressure', btzen.pressure, read_sensor),
    ('temperature', btzen.temperature, read_sensor),
    ('humidity', btzen.humidity, read_sensor),
    ('light', btzen.light, read_sensor),
    # notifying readers
    ('button', btzen.button, read_button),
    ('accelerometer', btzen.accelerometer, read_accelerometer),
]

parser = argparse.ArgumentParser()
parser.add_argument(
    '--verbose', default=False, action='store_true',
    help='show debug log'
)
parser.add_argument(
    '-i', '--interface', default='hci0',
    help='Host controller interface (HCI)'
)
parser.add_argument('mac', help='MAC address of device')
args = parser.parse_args()

level = logging.DEBUG if args.verbose else logging.INFO
logging.basicConfig(level=level)

uvloop.install()
asyncio.run(read_sensors(args))

# vim: sw=4:et:ai
