#!/usr/bin/env python3
#
# BTZen - Bluetooth Smart sensor reading library.
#
# Copyright (C) 2015-2018 by Artur Wroblewski <wrobell@riseup.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import asyncio
import logging

import btzen

async def read(name, reader):
    t1 = loop.time()
    while True:
        try:
            value = await reader.read()
            break
        except asyncio.CancelledError as ex:
            print('error for {}: {}: {}'.format(name, ex, ex.__cause__))
    t2 = loop.time()
    return (t2 - t1), value

async def read_sensor(name, reader):
    while True:
        t, value = await read(name, reader)
        value = '{:.1f}'.format(value)
        print('{}: {} ({:.4f}s)'.format(name, value, t))
        await asyncio.sleep(-loop.time() % 1)

async def read_accelerometer(name, reader):
    await reader.set_interval(0.1)
    while True:
        t, values = await read(name, reader)
        values = ', '.join('{:.4f}'.format(v) for v in values)
        print('accelerometer: {} ({:.4f}s)'.format(values, t))

async def read_button(name, reader):
    while True:
        t, value = await read(name, reader)
        print('button: {} ({:.4f}s)'.format(value, t))

parser = argparse.ArgumentParser()
parser.add_argument(
    '--verbose', default=False, action='store_true',
    help='show debug log'
)
parser.add_argument('device', help='MAC address of device')
args = parser.parse_args()

if args.verbose:
    logging.basicConfig(level=logging.DEBUG)
else:
    logging.basicConfig(level=logging.INFO)

print('connecting to {}...'.format(args.device))

sensor_def = [
    ('pressure', btzen.Pressure, False, read_sensor),
    ('temperature', btzen.Temperature, False, read_sensor),
    ('humidity', btzen.Humidity, False, read_sensor),
    ('light', btzen.Light, False, read_sensor),
    # notifying readers
    ('button', btzen.Button, True, read_button),
    ('accelerometer', btzen.Accelerometer, True, read_accelerometer),
]

# initialize all Sensor Tag sensors
items = [
    (name, reader, cls(args.device, notifying=notifying))
    for name, cls, notifying, reader in sensor_def
]
sensors =  [sensor for _, _, sensor in items]

# create tasks reading the sensor data
tasks = [reader(name, sensor) for name, reader, sensor in items]

# create connection manager
manager = btzen.ConnectionManager()
manager.add(*sensors)
tasks.append(manager)

print('sensors initialized')
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(asyncio.gather(*tasks))
finally:
    # connection manager closes all sensors
    manager.close()

# vim: sw=4:et:ai
